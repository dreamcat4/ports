#!/bin/sh
# $FreeBSD: head/multimedia/webcamd/files/webcamd.in 353901 2014-05-12 22:01:10Z nox $
#
# PROVIDE: webcamd
# REQUIRE: DAEMON LOGIN
# KEYWORD: shutdown
#
# It is recommended to configure webcamd in the following way:
#
# webcamd_enable="YES"
# webcamd_devices_0_name=<put here the single product name of your USB devices, as printed in the 2nd column of 'usbconfig' command. Do not repeat it.>
# webcamd_devices_{1,2,3...99}_name=<put in seperate variables the name of 2nd, 3rd *types* of connected USB device. Only if you have a mixture of different model types>
#
# Advanced settings:
#
# webcamd_startup_delay=<if multiple devices, the number of seconds to wait before launching the next instance of webcamd>
# webcamd_user=<the user to run webcamd as>
# webcamd_group=<the group to run webcamd as>
# webcamd_flags=<set additional global webcamd flags, applied on all instances>
#
# 2 other ways:
#
# webcamd_devices=<a list of USB device numbers, such as 'ugen2.2' for webcamd to attach to>
# webcamd_instance_{0,1,2,3}_flags=<to set manually each individual spawned instances, put here it's webcamd flags>
#
# You may use any of 3 ways in combination. Pick the right tool for right job.
# However do not use more than one method for each physical device.
#
# Examples:
# sysrc webcamd_enable=YES
# sysrc webcamd_startup_delay=2
#
# Method 1:
# sysrc "webcamd_devices_0_name=Acer Crystal Eye webcam SuYin"
# sysrc "webcamd_devices_1_name=SCEH-0036 SONY"
#
# Method 2:
# sysrc "webcamd_devices=ugen2.2, 7.3"
#
# Method 3:
# sysrc webcamd_startup_delay=0
# sysrc "webcamd_instance_0_flags=-L 127.0.0.1:5100:-1"
# sysrc "webcamd_instance_1_flags=-d ugen7.4 -v 2 -i 1 -m v4l2-dev.hflip=1"
#

. /etc/rc.subr

name=webcamd
rcvar=webcamd_enable
load_rc_config $name

: ${webcamd_enable:=NO}
: ${hald_enable:=NO}

: ${webcamd_user=webcamd}
: ${webcamd_group=webcamd}
: ${webcamd_startup_delay=1}

command=%%PREFIX%%/sbin/webcamd
command_args="-B -U ${webcamd_user} -G ${webcamd_group}"

start_cmd="${name}_start"
stop_cmd="${name}_stop"
status_cmd="${name}_status"

webcamd_pids()
{
  pids=$(pgrep -d ' ' $name)
  pids=${pids% }
  printf "${pids}"
}

webcamd_start()
{
  pids=$(webcamd_pids)

  if [ "$pids" ]; then
    echo "${name} already running?  (pid=${pids})."
    return 1
  fi

  if checkyesno hald_enable ; then
    command_args="$command_args -H"
  fi

  # webcamd_devices_N_name
  if [ "$webcamd_devices_0_name" ]; then
    usbconfig=$(usbconfig)

    n=0
    while [ "$n" -lt "100" ]
    do
      devices_name=$(eval "echo \$webcamd_devices_${n}_name")

      if [ "$devices_name" ]; then
        device_names="$device_names, $devices_name"

        found_devices=$(echo "$usbconfig" | grep "$devices_name" | cut -d ':' -f 1)
        if [ "$found_devices" ]; then
          autodetected_devices="$autodetected_devices $found_devices"
        fi

        n=$(expr $n + 1)
      else
        break
      fi
    done
  fi

  webcamd_devices="$autodetected_devices $webcamd_devices"
  webcamd_devices=$(echo "${webcamd_devices# }" | tr -s ',' ' ')
  num_instances_remaining=$(echo "$webcamd_devices" | wc -w | grep -o -E "[0-9]+")

  n=0
  while [ "$n" -lt "100" ]
  do
    if [ "$(eval "echo \$webcamd_instance_${n}_flags")" ]; then
      n=$(expr $n + 1)
    else
      break
    fi
  done
  num_instances_remaining=$(expr $num_instances_remaining + $n)

  # Check that necessary webcamd_ variables have been configured
  if [ ! "$webcamd_devices" ] && [ ! "$webcamd_instance_0_flags" ]; then
    if [ ! "$webcamd_devices_0_name" ]; then
      warn "failed to start ${name}."
      echo "webcamd settings need to be configured in /etc/rc.conf."
      echo "See %%PREFIX%%/etc/rc.d/${name} for more info."
      return 1
    else
      warn "failed to start ${name}."
      echo "No connected devices found of type: ${device_names#, }."
      return 1
    fi
  fi

  echo "Starting ${name}."

  # webcamd_devices
  for device in $webcamd_devices
  do
    # Launch an instance of webcamd for this device
    ${command} ${command_args} ${webcamd_flags} -d ${device}
    num_instances_remaining=$(expr $num_instances_remaining - 1)

    # Wait n seconds until launching the next instance for the next device
    if [ "$num_instances_remaining" -gt 0 ]; then
      sleep $webcamd_startup_delay
    fi
  done

  # additional instances
  n=0
  while [ "$n" -lt "100" ]
  do
    instance_flags=$(eval "echo \$webcamd_instance_${n}_flags")

    if [ "$instance_flags" ]; then

      if [ "$(echo "$instance_flags" | grep -o "\-U \|\-G ")" ]; then
        # Don't override user and group with the global value if they were explicitly set
        ${command} -B ${webcamd_flags} ${instance_flags}
      else
        # Launch an instance of webcamd with these specific instance flags
        ${command} ${command_args} ${webcamd_flags} ${instance_flags}
      fi

      num_instances_remaining=$(expr $num_instances_remaining - 1)
      n=$(expr $n + 1)

      if [ "$num_instances_remaining" -gt 0 ]; then
        sleep $webcamd_startup_delay
      fi
    else
      break
    fi
  done

  # Check that at least 1+ webcamd processes are persistent
  if [ "$webcamd_startup_delay" -gt 0 ]; then
    # but not if doing "fast-start". When webcamd_startup_delay = 0 seconds
    sleep 1
    pids=$(webcamd_pids)
    if [ "${pids}" ]; then
      echo "${name} is running as pid ${pids}."
    else
      if [ "$webcamd_devices" ]; then
        warn "webcamd not started."
        warn "Invalid configuration or USB devices not recognized: ${webcamd_devices% }."
      else
        warn "webcamd not started. Invalid configuration?"
      fi
      return 1
    fi
  fi
}

webcamd_stop()
{
  pids=$(webcamd_pids)
  if [ "${pids}" ]; then
    echo "Stopping ${name}."
    echo "Waiting for PIDs: ${pids}"
    for signal in TERM INT QUIT KILL HUP
    do
      kill -s ${signal} ${pids}
      sleep 1;
      pids=$(webcamd_pids)
      [ "${pids}" ] || break;
    done
  else
    echo "${name} is not running."
    return 1
  fi
}

webcamd_status()
{
  pids=$(webcamd_pids)

  if [ "${pids}" ]; then
    echo "${name} is running as pid ${pids}."
  else
    echo "${name} is not running."
    return 1
  fi
}

run_rc_command "$1"
